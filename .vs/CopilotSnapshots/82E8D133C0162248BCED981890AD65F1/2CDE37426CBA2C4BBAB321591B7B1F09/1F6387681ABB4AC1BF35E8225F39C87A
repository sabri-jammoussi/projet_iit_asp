using back.Models.Authentification;
using Back.Commun.Security;
using Back.Data.Infrastructure.EF;
using Back.Data.Infrastructure.EF.Enums;
using Back.Data.Infrastructure.EF.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace back.Services;

public class AuthService
{
    private readonly ILogger<AuthService> _logger;
    private readonly OltpDbContext _dbContext;
    private readonly PasswordHasherProvider _passwordHasherProvider;
    private readonly TokenService _tokenService;
    private readonly EmailValidator _emailValidator;
    private readonly PasswordValidator _passwordValidator;

    public AuthService(
        ILogger<AuthService> logger,
        OltpDbContext dbContext,
        PasswordHasherProvider passwordHasherProvider,
        TokenService tokenService,
        EmailValidator emailValidator,
        PasswordValidator passwordValidator)
    {
        _logger = logger;
        _dbContext = dbContext;
        _passwordHasherProvider = passwordHasherProvider;
        _tokenService = tokenService;
        _emailValidator = emailValidator;
        _passwordValidator = passwordValidator;
    }

    /// <summary>
    /// Register a new user.
    /// </summary>
    public async Task<IActionResult> Register(RegistrationRequest request)
    {
        _logger.LogInformation("Registering user with email: {Email}", request.Email);

        // Check if user with the same email already exists
        var userInDb = await _dbContext.Accounts.FirstOrDefaultAsync(u => u.Email == request.Email);
        if (userInDb != null)
            throw new Exception("Email is already registered.");

        // Validate password
        var validPassword = _passwordValidator.ValidatePassword(request.Password);
        if (!validPassword)
            throw new Exception("Le mot de passe doit contenir au moins 8 caractères, une lettre majuscule, une lettre minuscule, un chiffre et un caractère spécial.");

        // Validate email
        var validEmail = _emailValidator.ValidateEmail(request.Email);
        if (!validEmail)
            throw new Exception("Email invalid");

        // Generate password hash and salt
        _passwordHasherProvider.CreatePasswordHash(request.Password, out byte[] passwordHash, out byte[] passwordSalt);

        var newUser = new AccountDao
        {
            FirstName = request.FirstName,
            LastName = request.LastName,
            Email = request.Email,
            PasswordHash = passwordHash,
            PasswordSalt = passwordSalt,
            Role = UserRole.Client,
        };

        _dbContext.Accounts.Add(newUser);
        await _dbContext.SaveChangesAsync();

        return new OkResult();
    }

    /// <summary>
    /// Login user and return JWT token.
    /// </summary>
    public async Task<ActionResult<AuthResponse>> Login(AuthRequest request)
    {
        // Check if the user exists in the database
        var userInDb = await _dbContext.Accounts.FirstOrDefaultAsync(u => u.Email == request.Email);
        if (userInDb is null)
            throw new Exception("Email ou Mot de passe invalid !");

        if (userInDb.PasswordHash is null || userInDb.PasswordSalt is null)
            throw new Exception("Email ou Mot de passe invalid !");

        if (!_passwordHasherProvider.VerifyPasswordHash(request.Password, userInDb.PasswordHash, userInDb.PasswordSalt))
            throw new Exception("Email ou Mot de passe invalid !");

        // Map to TokenUserDto for token creation
        var tokenUser = new TokenUserDto
        {
            Id = userInDb.Id,
            FirstName = userInDb.FirstName,
            LastName = userInDb.LastName,
            Email = userInDb.Email,
            Role = userInDb.Role.ToString()
        };

        var accessToken = _tokenService.CreateToken(tokenUser);

        var response = new AuthResponse
        {
            Token = accessToken,
        };

        return response;
    }
}
